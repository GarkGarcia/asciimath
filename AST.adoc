= Asciimath Grammar and AST

== Grammar

The syntax for ASCIIMath in EBNF style notation is

[source]
----
asciimath = expr*
expr = intermediate fraction?
fraction = '/' intermediate
intermediate = simp sub? super?
super = '^' simp
sub =  '_' simp
simp = constant | paren_expr | unary_expr | binary_expr | text
paren_expr = lparen expr rparen
lparen = '(' | '[' | '{' | '(:' | '{:'
rparen = ')' | ']' | '}' | ':)' | ':}'
unary_expr = unary_op simp
unary_op = 'sqrt' | 'text'
binary_expr = binary_op simp simp
binary_op = 'frac' | 'root' | 'stackrel'
text = '"' [^"]* '"'
constant = number | symbol | identifier
number = '-'? [0-9]+ ( '.' [0-9]+ )?
symbol = /* any string in the symbol table */
identifier = [A-z]
----

== Abstract Syntax Tree

The parser returns an abstract syntax tree consisting of symbols, strings, Hashes and Arrays.
Each expression 'node' of the AST is one of the following forms:

Sequence::
+
Sequences of expressions are returned as an Array of nodes.

Symbols::
+
Mathematical operators, function names, arrows, accents, greek letters, etc. are all represented as Symbol objects.

Literals::
+
Literal text strings are represented as String objects.

Parentheses::
+
[source]
----
{
  :type => :paren
  :e => <sub expression>
  :lparen => <left Symbol or String>
  :rparen => <right Symbol or String>
}
----

Super and Sub Script::
+
[source]
----
{
  :type => :subsup
  :e => <base expression>
  :sub => <subscript expression>
  :sup => <superscript expression>
}
----

Unary Expressions::
+
[source]
----
{
  :type => :unary
  :e => <operand expression>
  :op => <operator Symbol or String>
}
----

Binary Expressions::
+
[source]
----
{
  :type => :binary
  :e1 => <first operand expression>
  :e2 => <second operand expression>
  :op => <operator Symbol or String>
}
----

Matrices::
+
[source]
----
{
    :type => :matrix
    :rows => <Array of Arrays of expressions>
    :lparen => <left Symbol or String>
    :rparen => <right Symbol or String>
}
----